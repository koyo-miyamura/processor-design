・各コンポーネントの概要

top_test.v : topモジュールのテストフィクスチャ本体
            パラメータの説明
                IN_TOTAL     : シュミレーション時間(clock cycle)
                CYCLE        : クロックサイクル時間(ns)
                HALF_CYCLE   : クロックサイクル時間の半分(ns)
                IMEM_SIZE    : 命令メモリのサイズ(Byte)
                DMEM_SIZE    : データメモリのサイズ(Byte)
                IMEM_LATENCY : 命令メモリのレイテンシ(clock cycle)
                DMEM_LATENCY : データメモリのレイテンシ(clock cycle)
                STDOUT_ADDR  : このアドレスに対しsb命令を実行すると格納された値を文字として出力
                EXIT_ADDR    : このアドレスに対しストア命令を実行するとシミュレーションを終了

            大まかな動作の説明
	      １．命令メモリおよびデータメモリの内容をあらかじめ準備したファイル(Imem.dat，Dmem.dat)から読み込みます．
           	  命令メモリに読み込むファイルは，実行する命令が16進数で書かれたものです．

	      ２．一回リセットを行い，
    	          その後，1クロックごとにループをforループを回って，適当なクロック数(IN_TOTAL)で終了します．

	      ３．クロックサイクル中に，メモリの読み出しや書き込みがあればそれぞれのtaskで処理します．

	      ４．forループが終わった後，プロセッサ内部のレジスタファイルに格納されたデータと，
    	          メモリに格納されたデータをそれぞれファイルに書き出します(Dmem_out.dat, Reg_out.dat)．

            検証方法
              得られたレジスタとメモリのデータをあらかじめ準備したそれぞれの期待値ファイルと比較して，
              (UNIXコマンドのdiffを用いる)
              プロセッサの挙動が正しいかどうか検証します．

            前のバージョンからの変更点
              top_test.v は三原さんから頂いた top の test_fixture に，
                1. 命令メモリ，データメモリのレイテンシの調節機能
                2. プログラムから出力を行うための STDOUT_ADDR の付加
                3. プログラムから明示的に verilog のシミュレーションを終了させるための EXIT_ADDR の付加
              を行ったものです．

top_test_ml1.v : topモジュールのテストフィクスチャ本体．
                 メモリレイテンシを１に固定．(ACKI_n，ACKD_n が常に0)

mips-cross   : テストプログラム，設計したプロセッサ用にコンパイルするためのスクリプト群
 |
 |- asm : アセンブリ言語で書いたテストプログラム(期待値ファイルとして Dmem_e.dat，Reg_e.datを含む)
 |
 |- c : c言語で書いたテストプログラム(CHECK PASSED!!と表示されたら成功，CHECK FAILED!!と表示されたら失敗)
 |
 |- Makefile.defaults : c言語で書いたプログラム用の Makefile
 |
 |- Makefile-asm.defaults: アセンブリ言語で書いたプログラム用の Makefile
 |
 |- tools : 設計したプロセッサ用の命令メモリ，データメモリの内容を生成するためのスクリプトなど
     |      Makefile.defaults，Makefile-asm.defaults の中で使用
     |
     |- convimem.sh  : verilog用の命令メモリ記述をディスアセンブルするスクリプト
     |
     |- convdmem.awk : verilog用のデータメモリ記述をディスアセンブルするスクリプト
     |
     |- mod_s.awk : 'mipsisa32-elf-gcc -S -Tidt32.ld hoge.c' で生成されたアセンブリコード(hoge.s)に対し，
     |              (1) main関数にスタックポインタの初期化記述を挿入
     |              (2) 命令が 0x10000 から始まるようにする
     |              (3) データが 0x10000 から始まるようにする
     |              を行うスクリプト
     |
     |- set_jal_target.awk : 'mipsisa32-elf-objdump -D -z hoge' でディスアセンブルされたものに対し，
     |                       jal命令(関数呼び出し)のターゲットを設定するスクリプト
     |
     |- offdb.awk : 'mipsisa32-elf-objdump -D -z hoge' でディスアセンブルされたものに対し，
     |              遅延分岐を無効化するスクリプト
     |              具体的には，
     |              (1) 分岐命令(ジャンプ命令)とその後続命令との入れ替え
     |              (2) 分岐命令の場合，オフセット値を1減らす(PCの値が変わったので)
     |              をやっている
     |
     |- getmem.awk : 'mipsisa32-elf-objdump -D -z hoge' でディスアセンブルされたものから，
     |               ユーザ領域(0x10000〜)の命令とデータを取り出し verilog で読める形式にして，
     |               Imem_u.dat，Dmem_u.dat に出力
     |
     |- Imem_s.dat : スーパバイザ領域(0x0 〜 0x10000)の命令メモリの内容
     |               簡単な割り込み処理ルーチンを含む．詳しくは './convimem.sh Imem_s.dat' とやって内容を見てください．
     |
     |- Dmem_s.dat : スーパバイザ領域(0x0 〜 0x10000)のデータメモリの内容


・テストプログラムのコンパイルと実行方法
  最初に，Makefile.defaults と Makefile-asm.default の中の
    TOOLS_DIR = ${HOME}/test_pack/mips-cross/tools
  の部分を適切に設定する．(デフォルトは /home/hoge/test_pack/mips-cross/tools)

  テストプログラムは make でコンパイルします．
  これで，Imem.dat, Dmem.dat ができるはずです．
  'make clean'と打つと中間ファイルやImem.dat，Dmem.datなどを消すことができます．
  また，makeで失敗するときに'make clean'と打ったあとにmakeを行うとうまくいくことがあります．

  まずは，test_pack/mips-cross/asm の下のテストプログラムで検証を行うといいと思います.
  おすすめのテストプログラム実行順序
  load -> store -> p2 -> p4 -> p5 -> p3 -> Interrupt


・アセンブリ言語で書いたテストプログラムの説明
load: ロード命令のテストプログラム
store: ストア命令のテストプログラム
p2: いろいろ．
p3: 全命令のテスト．算術割り込みを含む．
p4: 全演算命令のテスト．算術割り込みを含む．
p5: 全分岐命令，全ジャンプ命令のテスト

Interrupt: 割り込みのテストを行うプログラム
 |- IF: IFステージの割り込み処理のテスト
 |   |- Ile : 命令アクセス・メモリ保護違反
 |   |- Mis : 命令アクセス・ミスアラインメント
 |
 |- ID: IDステージの割り込み処理のテスト
 |   |- UDI : 未定義命令
 |   |- TMR : 特権命令例外
 |
 |- EX: 算術割り込みのテスト
 |
 |- MEM: MEMステージの割り込み処理用のテストを行うプログラム
 |   |- load  : load 命令のデータアクセス・ミスアラインメント，データアクセス・メモリ保護違反割り込みのテスト
 |   |- store : load 命令のデータアクセス・ミスアラインメント，データアクセス・メモリ保護違反割り込みのテスト
 |
 |- OUT: マスク可能外部割り込みのテストプログラム. 
         top のテストモジュール(top_test.v)を top_oint_test.v に変えてやってください


・c 言語で書いたのテストプログラムの説明
プログラムの説明
  hello  : "Hello World!" と出力するプログラム
  prime  : 素数を求めるプログラム
  napier : 自然対数の底e を計算するプログラム
  pi     : 円周率を計算するプログラム
  sort   : ソートのプログラム

ディレクトリの説明
  ans   : 答えの生成用のプログラム
  large : 大きな入力
  mid   : 中ぐらいの入力
  small : 小さな入力
  test  : 小さな入力．結果を詳細に出力する

実行するときの注意
  (1) top_test.v の IN_TOTAL を十分大きく
      IN_TOTAL が小さいとプログラム実行が終わる前にシミュレーションが終わってしまう
  (2) top_test.v の以下の部分のコメントアウト
      ========================================
       initial begin
           $monitor($stime," PC=%h", IAD);
           $shm_open("waves.shm");
           $shm_probe("AS");
       end
     ========================================

      $monitor: 消さないとプログラムの文字の出力がmonitorによる出力に混ざってしまう
      $shm_open, $shm_probe: waveform のファイル(waves.shm/*)が作られないようにする
                             実行時間が長いとwaveformのファイルがかなり大きくなってしまう

その他
  gcc -DDEBUG hoge.c -o hoge とやれば普通に実行できるバイナリを生成できるようにしてます


・アセンブリ言語で書いたプログラムをverilog用にコンパイルするには
基本的に，テストプログラムのソースコードとMakefileを真似して書けばできます．
このとき，以下のように書いてください．
==============================
	.text
main:
	# プログラム本体

	.data
	# データ
==============================


・c言語で書いたプログラムをverilog用にコンパイルするには
基本的に，テストプログラムのソースコードとMakefileを真似して書けばできます．
このとき，以下の制約を守ってください
    1．関数は自分で明示的に書いたものしか使わない
         printf，scanf，strlen，strcmp などは使えない．
    2. 関数の本体は main 関数のあとに書く．
         main 関数の先頭アドレスが確実に  0x10000 になるようにするため
    3. グローバル変数には必ず 'static' をつける
         static をつけないとなんだかうまくいかない...
    4. グローバルな配列は必ず初期化する
         初期化しないとなんだかうまくいかない...
    5. 関数ポインタによる関数の呼び出しを行わない
         関数ポインタによる関数呼び出しを行うと，アドレス 0 に飛んでしまう

・最後に
バグがあったら今里までご報告下さい．

